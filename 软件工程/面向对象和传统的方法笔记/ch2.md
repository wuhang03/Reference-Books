# 第2章 软件生命周期模型

## 2.1 理论上的软件开发

一个系统是从零开始的

然而实践与理论有很大不同：

1. 软件开发人员会犯错
2. 开发过程中用户需求会发生变化

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-1.png" style="zoom:50%;" />

进化树生命周期模型

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-2.png" style="zoom:50%;" />*

实线表示开发，虚线表示维护



瀑布模型

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-3.png" style="zoom:50%;" />

如果在设计期间发现了一个需求中的差错引起的差错，顺着箭头向上可以回溯并进行改正



相比于瀑布模型，进化树模型在每一幕的结尾有一个基准



## 2.3 Winburg小型实例研究心得

软件产品的开发会因为一些不相干的因素出现错误，比如较差的实现策略和较慢的算法

事实上这个项目在开发过程中出现的问题已经是很小的，大型软件项目在开发过程中会遇到更多的不确定情况。



## 2.4 野鸡拖拉机公司小型实例研究

请参见原文



## 2.5 迭代与递增

由于移动目标和开发过程中的明显错误，实际软件开发周期类似于上面所说的瀑布模型和进化树模型

在现实情况当中，谈论分析阶段是没有意义的，分析阶段的操作遍布在生命周期的各个阶段

考察一个软件的后续版本，如规格说明文档或一个编码模块，基本的过程是**迭代**的，即我们先制作第一版，然后修改它并制作第二版，最终构建一个满意的版本。

**迭代是软件工程的一个固有特性**



米勒法则施加的限制

心理学教授米勒指出：人类最多只能将精力集中在7件事情上

然而一个编码制品可能远超7个变量，一个需求文档可能远超7个

人类处理信息量的限制的一个方法是**逐步求精**，即集中精力于事情目前最重要的方面，把那些不太紧急的方面向后拖延。

换句话说，事情的每个方面最终都要处理，但是要按照目前的重要性依次进行。

这意味着我们开始建造一个软件项目仅解决目标的一小部分，然后进一步考虑其他问题并加入新的片段，这就是一个递增过程，。

**递增也是软件工程的一个固有特性**



实践中迭代和递增相互结合使用：

* 软件制品是递增的
* 每个增量通过多次迭代

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-4.png" style="zoom:50%;" />

软件的生命周期当中有五个核心工作流： 需求工作流、分析工作流、设计工作流、实现工作流和测试工作流

所有的工作流都在生命周期中进行，但是在某一时间段，一个工作流的重要性会超过其他工作流

* 计划和文档活动贯穿整个迭代-递增生命周期；测试在每次迭代期间，特别是在每次迭代结束的时候，是一个主要活动



## 2.6 修订的Winburg小型实例研究

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-5.png" style="zoom:50%;" />

请参见原文



## 2.7 迭代和递增的风险和其他方面

另一种考察迭代和递增的方式是项目作为整体可以划分为更小的项目，每个小项目扩展出需求、分析、设计、实现和测试制品。

迭代递增模型的**优点**：

1. 为检查软件产品是否正确提供多个机会。每次迭代都包括测试流，越晚检查出差错，付出的代价越大。
2. 在生命周期的相对早期可以确定其蕴含的结构的鲁棒性。鲁棒性是开发软件产品期间的重要质量特性在交付后维护期间尤其重要。软件结构越健壮，软件改变起来就越有弹性。
3. 使我们较早的减轻风险。
4. 我们总是有一个改软件的工作版本。客户和目标用户可以试验该版本，然后决定需要做什么改变以确定未来的实现能够完全满足。



## 2.8 迭代和递增的控制

瀑布模型： 将软件产品看作一个整体

迭代-递增模型：将软件产品看作一套递增

对于每个递增依次重复执行需求、分析、设计和实现阶段，直到明确的不需要进一步的迭代。



## 2.9 其他生命周期模型

### 2.9.1 编码-修补生命周期模型

实现产品时没有需求或规格说明，也没有进行设计方面的尝试，开发者只是简单的将代码拼凑在一起，为满足要求多次改写。

实际上的花费远超

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-6.png" style="zoom:50%;" />

### 2.9.2 瀑布生命周期

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-7.png" style="zoom:50%;" />

关键点： 在任何阶段的文档完成并该阶段被质量保证小组认可之前，该阶段是没有完成的。

瀑布模型的每个阶段都包含测试

瀑布模型规定在每个阶段提供文档，然而文档驱动也是瀑布模型的弱点。

问题: 客户按照规格说明文档的描述所理解的产品和实际产品有很大不同。瀑布模型如此依赖于文字的规格说明，会直接导致建造出的产品不符合客户的真正需求



### 2.9.3 快速原型开发生命周期模型

快速原型: 与产品子集功能相同的工作模型

<img src="E:\电子书\软件工程\面向对象和传统的方法笔记\img\2-8.png" style="zoom:50%;" />

第一步是建造一个快速原型，让客户和未来的用户试用。

一旦客户认为快速原型确实满足了大多数要求，则开发者拟制规格说明文档

优点： 产品的开发从快速原型到交付的产品基本上是线性的：

1. 快速原型已经得到用户的确认，由此生成的规格说明文档会是正确的
2. 考察设计阶段。

快速原型的基本特性体现一个快字。开发者应当尽可能快的建造原型，以加快软件开发进程。毕竟快速原型存在的唯一作用就是确定用户想要的是什么。

所以，**速度是关键**。



### 2.9.4 开源生命周期

几乎所有优秀的开源软件都要经过两个非形式阶段：

1. 建立初始版本，发布并供别人下载
2. 用户成为合作者： 一些用户报告缺点，而另一些用户提出修复缺点的建议

第二个非形式阶段中的活动：

1. 报告并改正缺点是纠正性维护
2. 添加额外的功能是完善性维护
3. 为该程序提供一个新环境转换接口是适应性维护



不开源与开源生命周期的关键区别：

* 开源软件由非雇用的自愿者进行维护，强烈鼓励用户提交缺陷报告 （描述源码出现的错误以及如何纠正）；对于非开源的软件来说，由该软件的拥有公司进行维护，用户有时候会提交故障报告（显现出来的非正确特性的报告）。
* 不开源软件大约每年发布一次，每个新版发布由小组成员在发布之前仔细检查；开源软件的格言是“尽早发布，经常发布”。假设更昂贵的测试由外围小组完成。

开源生命周期模型同时拥有**代码-修复模型**和**快速原型模型**的特性。



限制： 实用性



### 2.9.5 敏捷过程

极限编程由迭代-递归模型发展而来。

第一步是软件开发小组确定客户希望产品支持的各种特性（情节），向客户通报实现每个特性需要的时间和花费。

客户使用成本-效益分析方法，根据小组成员提供的时间和花费进行选择。将**构件**分成更小的**任务**

程序员首先设计出任务的测试用例，称为**测试驱动开发**。然后两个程序员在一台计算机前进行结对编程。之后将任务集成到产品的当前版本当中。



与传统方法相比XP的特性：

* 一个客户代表一直与XP小组一起工作
* XP小组的所有成员共同完成规格说明、分析、设计、编码和测试
* 建造产品的过程中设计在不断的调整。这个过程称为重构。



当用户的需求很模糊时，敏捷过程看起来对于建立小型软件产品是有用的方法。



### 2.9.6 同步-稳定生命周期

对用户需求进行优先级排序

将工作分为3-4个构件，第一个包含最重要的构件，每个构件由很多个小组并行进行开发

每天工作结束前所有小组进行工作**同步**，在每个构件结束时进行**稳定**。



### 2.9.7 螺旋生命周期模型

构建原型是最小化某些类型风险的一个途径

通过使用原型或者其他方法最小化风险是螺旋生命模型中蕴含的概念